comment_id,user,date,body
2486342075,ankurdotb,2024-11-19T17:34:51+00:00,"Just thinking out loud, coming from how key management has been done in other wallets I'm familiar with like Veramo and blockchain wallets: they often allow keys to be referenced using friendly or ""alias"" names, e.g., when storing in keystore, I name a key as `ankurs-main-key` or `ankurs-secondary-key`. Note that this is just a keystore reference, not how the key needs to be referenced in the DID Document, e.g., while the specified key is `ankurs-main-key`, when set into a DID Document in the verification method/authentication section, it might be referenced/published as `key-1`.  Here's how Veramo currently stores keys when storing in databases:   <img width=""101"" alt=""Screenshot 2024-11-19 at 18 23 12"" src=""https://github.com/user-attachments/assets/07fe686a-6036-4d37-8b6b-6a010fc0cc31""> <img width=""108"" alt=""Screenshot 2024-11-19 at 18 23 19"" src=""https://github.com/user-attachments/assets/0afc291f-5ce8-49d5-a906-0df9185dbf15"">  Veramo stores private keys separately from public keys, storing them in a hex representation which has a `alias` as primary key. Personally, I'd store a unique key ID and then make alias a secondary unique constraint (might be useful in key deprecation/deletion scenarios, to only allow one ""active"" key to have a unique alias, but keep deprecated keys still referencable by a key ID and their known alias).  The public key table is a bit closer to what you described above @dbluhm. This table makes the assumption that keys are used as controllers/authentication for DIDDocs only, but I can see that perhaps the addition of a `relationship` property could accommodate the idea you were talking about as well as storing what key fragment it's known by in that DIDDoc.  I don't know how common it is for people to reuse keys across DIDDocs; I suspect not for primary controller/authentication, but perhaps for other key agreement properties. So I do think when keys are stored, they shouldn't have a hard assumption that it's only used/linked to one DIDDoc, or only one type of relationship (since the same key might be used in auth as well as `assertionMethod` as well as...)"
2486917909,dbluhm,2024-11-19T22:56:24+00:00,"I was thinking through this some more and made an important discovery/re-discovery; I was mistaken in thinking that tags could only be string values. A list of strings is also accepted, enabling us to tag a key with as many DIDs, aliases, verification method ids, and relationships as we want without having to worry about lookup challenges. I'll update the proposal with this info.  edit: the proposal has been updated"
2487007665,dbluhm,2024-11-19T23:58:42+00:00,"The updated proposal is better than the starting point but introduces a new problem; the structure assumes that the verification relationship of a key is the same for all the DIDs it's assigned to.  I like the simplicity of being able to directly tag and query keys but to enable multiple DIDs to use the same key in different ways, I think we would have to have a separate category of verification method records:  - **Category:** `vm` - **Name:** verification method ID - **Value:** key id (multikey representation) - **Tags:**   - `did`: did the vm is associated with   - `key_type`: essentially the Askar `KeyAlg` value   - `rel`: A list of verification relationships as defined by the DID Core spec; e.g. `[""authentication"", ""assertionMethod""]`. This represents the intended use of this key.  Performing an operation with a key where we're identifying it by VM ID or by DID + relationship/purpose would require a two step process. First lookup the VM by tags then lookup the key by ID/name."
2491872780,dbluhm,2024-11-21T17:39:08+00:00,"Yet another lookup mechanism idea. Instead of having a layer of indirection with the VM records as proposed in my previous comment, we could just have multiple key records that contain the same key material and are just tagged with different values. I think this means we would end up with two different kinds of ""key records;"" one where name is the multikey representation and one where the name is the verification method ID. The one with multikey name would be what is created for keys that are not (yet) bound to a DID. And then the other would of course be keys that are bound with a DID. Whether the same key exists in both representations depends on the DID method that we're creating a DID for. If we need to know the complete DID Document before the DID can be created, then we'll end up with unbound keys until the ID of the DID is known. For example, in did:peer, we have to generate our keys before we know the DID itself since the key material contributes to the DID creation. But did:web, as a counterexample, the DID is known (or can be known) before keys associated with it are created so keys in a did:web document could be created with a known Verification Method ID from the start.  ## Unbound keys  - **Category:** Key - **Name:** Multikey representation - **Value:** the key itself - **Tags:**   - Implicit tag for the `KeyAlg` (automatically included on every key)   - `alias`: A human-friendly alias (or list of aliases) that can help identify a key to a user  ## Bound Keys  - **Category:** Key - **Name:** Verification method ID - **Value:** the key itself - **Tags:**   - Implicit tag for the `KeyAlg` (automatically included on every key)   - `did`: the DID this key is associated with   - `rel`: A list of verification relationships as defined by the DID Core spec; e.g. `[""authentication"", ""assertionMethod""]`. This represents the intended use of this key.  This is essentially the same proposal as the separate VM record proposal with the critical difference that we just have multiple key entries for the same key material so we don't have to do a two step look up. "
